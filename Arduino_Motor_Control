#NODEMCU arduino sketch.


#include <Servo.h>
#include <L298N.h>
#define DEBUG

#define DRIVE_MOTOR_PWN_ENA_PIN 4
#define DRIVE_MOTOR_IN1_PIN 0
#define DRIVE_MOTOR_IN2_PIN 5
#define DRIVE_MOTOR_PWM_PERIOD  (10000)
#define DRIVE_MOTOR_CHANNEL 8

#define STEERING_MOTOR_PWM_PIN  14
#define STEERING_MOTOR_PWM_MAX 1900
#define STEERING_MOTOR_PWM_MIN 1150
#define STEERING_MOTOR_PWM_CENTER (STEERING_MOTOR_PWM_MAX - STEERING_MOTOR_PWM_MIN) / 2 + STEERING_MOTOR_PWM_MIN
#define STEERING_MOTOR_CHANNEL 1

int max_steering_input = 32768;

L298N driveMotor(DRIVE_MOTOR_PWN_ENA_PIN, DRIVE_MOTOR_IN1_PIN, DRIVE_MOTOR_IN2_PIN);
Servo steeringServo;

L298N::Direction current_driving_direction = L298N::FORWARD;

bool serialDataReady=false;
int max_right_steering_angle = 60;
int max_left_steering_angle = 150;


int max_speed = 35;
int min_speed = 20;

uint8_t incomingByte = 0x0;
bool commandReceived = false;

enum command_t{DRIVE, TURNLEFT, TURNRIGHT, DIRECTION, BRAKE, TURN};

command_t commandType;
uint8_t commandData = 0x0;


void setup() {
  // put your setup code here, to run once:
  steeringServo.attach(STEERING_MOTOR_PWM_PIN, STEERING_MOTOR_PWM_MIN, STEERING_MOTOR_PWM_MAX);
  
  //Serial.begin(115200);
  Serial.begin(115200);
  
  steeringServo.write(STEERING_MOTOR_PWM_CENTER);
  
  driveMotor.setSpeed(0);
}

#ifdef DEBUG
  void dprint(uint8_t d){
    Serial.print(d);
    Serial.flush();
  }
  void dprintln(uint8_t d){
    Serial.println(d);
    Serial.flush();
  }
  void dprintln(char x[]){
    Serial.println(x);
    Serial.flush();
  }  
  void dprint(char x[]){
    Serial.print(x);
    Serial.flush();
  }
#endif


int map_steering_angle(int val){
  //not used
  int microseconds = 0;

  microseconds = map(val, -max_steering_input, max_steering_input, max_left_steering_angle, max_right_steering_angle);
  //the way this is physically installed, the servo is centered 50 -150 is close to what it needs to do.
  
  return microseconds;
}
void turn_left(int angle){

 steeringServo.writeMicroseconds(map(angle, 0,255 , STEERING_MOTOR_PWM_MIN,STEERING_MOTOR_PWM_MAX));

}

void turn_right(int angle){

 steeringServo.writeMicroseconds(map(angle, 0,255 , STEERING_MOTOR_PWM_MIN,STEERING_MOTOR_PWM_MAX));

};

void drive(uint8_t speed){
    driveMotor.setSpeed(speed*4);
    driveMotor.run(current_driving_direction);
}

void apply_brakes(){
      driveMotor.setSpeed(0);

  driveMotor.stop();
}

void set_drive_direction(L298N::Direction driveDirection){
  if (driveDirection != current_driving_direction){
    apply_brakes();
    current_driving_direction = driveDirection;
  }
}

void turn_center(){
  steeringServo.write(STEERING_MOTOR_PWM_CENTER);
}

void turn(int angle){
  if (angle == 0){
    turn_center();
  }
  else{

  steeringServo.write(angle);
  #ifdef DEBUG
          dprint("Turning: ");
      dprintln(angle);

  #endif
  }
}

void loop() {

  if (Serial.available()){
    incomingByte = Serial.read();
    #ifdef DEBUG
      dprint("serial data received: ");
      dprintln(incomingByte);
    #endif
    if (!commandReceived){
      switch (incomingByte){
      
        case 0x0A:{
          commandType=BRAKE;
          commandReceived=true;
          //Serial.flush();
          #ifdef DEBUG
            dprintln("Brake command received");
          #endif
        };break;
        case 0x0B:{
          commandType=DRIVE;
          commandReceived=true;
          //Serial.flush();
          #ifdef DEBUG
            dprintln("Drive command received");
          #endif          
        };break;
        case 0x0C:{
          commandType=TURNLEFT;
          commandReceived=true;
          //Serial.flush();
          #ifdef DEBUG
            dprintln("Turn Left Command Received");
          #endif          
        };break;
        case 0x0E:{
          commandType=TURNRIGHT;
          commandReceived=true;
          //Serial.flush();
          #ifdef DEBUG
            dprintln("Turn right command received");
          #endif          
        };break;
        case 0x0F:{
          commandType=DIRECTION;
          commandReceived=true;
          //Serial.flush();
          #ifdef DEBUG
            dprintln("direction command received");
          #endif          
        };break;
        default:{
          ;
        };break;
      };
    }
    else{
      commandData=incomingByte;
          #ifdef DEBUG
            dprint("data received: ");
            dprintln(incomingByte);
          #endif      
      serialDataReady=true;
      commandReceived=false;
    }
  }
  if (serialDataReady){
    
    switch (commandType){
      case BRAKE:{
        apply_brakes();
      };break;
      case DRIVE:{
        drive(commandData);
      };break;
      case TURN:{
        turn(commandData);
      }
      case TURNLEFT:{
        turn_left(commandData);
      };break;
      case TURNRIGHT:{
        turn_right(commandData);
      };break;
      case DIRECTION:{
        if (commandData == 0x00){
          set_drive_direction(L298N::FORWARD);
        }
        else if (commandData == 0x01) {
          set_drive_direction(L298N::BACKWARD);
        }
        else {
          dprintln("invalid command received");
        }
      };break;
      
    };

    serialDataReady=false;
    commandData=0x0;
    commandReceived=false;
  }


  #ifdef DEBUG
    //dprintln("tick");
   #endif


  // put your main code here, to run repeatedly:
}